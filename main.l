
/*
Path
cd Documentos/Lenguajes/AnalizadorLexico/
Build

flex main.l

cc lex.yy.c -lfl

Run 

a.out < sourceCode


esc치ner para un lenguaje de juguete al estilo de Pascal */

%{
/* se necesita esto para la llamada a atof() m치s abajo */
#include <math.h>
%}
/*Definiciones 
<Nombre>  <expresion_regular>
*/

DIGITO  [0-9]
NUMBER [0-9]+|[0-9]+\.[0-9]+|\.[0-9]+
ID      [pqrt][0-9]{0,5}
VOID	[ \t\n]+
END	[;]
TEXT	\"[^\"\n]*\"
COMMENT \#[a-zA-Z][a-zA-Z0-9]*

/* Reglas Lexicas 
Patrones que se reconoceran del fichero de entrada

<patron(expresi칩n_regular)> <acci칩n(codigo C a ejecutar)>

*/
%%

{VOID}			;

{DIGITO}+		{ printf( " entero "); }

{DIGITO}+"."{DIGITO}*	{ printf( "real" ); }



{ID}			{ printf( " predicado " ); }

{ID}[a-zA-Z0-9]*	{ printf( " error " ); }
{NUMBER}[a-zA-Z]*	{ printf( " error " ); }

"+"|"-"|"*"|"/"   	{ printf( " operadorAritmetico "); }
"&&"|"\|\|"|"->"	{ printf( " operadorLogico "); }
"="|"<>"|"<"|">"   	{ printf( " operadorRelacional "); }

"{"[^}\n]*"}"     /* se come una linea de comentarios */

{END}			{ printf( "\n"); }

.           printf( "Error" );

%%

/*Codigo C rutinas de usuario (opcional) */

main( argc, argv )
int argc;
char **argv;
    {
    ++argv, --argc;  /* se salta el nombre del programa */
    if ( argc > 0 )
            yyin = fopen( argv[0], "r" );
    else
            yyin = stdin;
    
    yylex();
    }
